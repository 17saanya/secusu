'use strict';

var ChatServer = function ChatServer(options) {
    var _this = this;

    /**
     * IO server instance.
     *
     * @type {io|*}
     */
    _this.io = options.io;

    /**
     * Environment variables.
     *
     * @type {ENV|*}
     */
    _this.ENV = options.ENV;

    /**
     * Rooms list with User objects.
     *
     * @type {Array}
     */
    _this.rooms = [];

    /**
     * List of all users connected to chat.
     *
     * @type {Array}
     */
    _this.users = [];
};

/**
 * Initialize function.
 */
ChatServer.prototype.init = function () {
    var _this = this;

    _this.io.of('/c').on('connection', function (socket) {
        _this.handleConnection(socket);
    });
};

/**
 * Socket handler for an incoming socket.
 *
 * @param socket
 */
ChatServer.prototype.handleConnection = function (socket) {
    var _this = this;

    socket.on('room.create', function (args) {
        if (typeof args == 'undefined') {
            socket.emit('room.create', {success: false, errors: ['Empty arguments']});
            _this.debug('Cannot create room without arguments');
            return;
        }

        if (typeof args.password == 'undefined' || args.password.length == 0) {
            socket.emit('room.create', {success: false, errors: ['Password is required']});
            _this.debug('Cannot create room without password');
            return;
        }

        _this.createRoom(socket, args.password);
    });

    socket.on('room.join', function (args) {
        if (typeof args == 'undefined') {
            socket.emit('room.join', {success: false, errors: ['Empty arguments']});
            _this.debug('Cannot join to room without arguments');
            return;
        }

        if (typeof args.room == 'undefined' || args.room.length == 0) {
            socket.emit('room.join', {success: false, errors: ['Room name is required']});
            _this.debug('Cannot join to room without room name');
            return;
        }

        if (typeof args.password == 'undefined' || args.password.length == 0) {
            socket.emit('room.join', {success: false, errors: ['Password is required']});
            socket.broadcast.to(args.room).emit('room.join.attempt', {
                success: false,
                room: args.room,
                errors: ['Somebody tried to join room with empty password']
            });
            _this.debug('Cannot join to room without password');
            return;
        }

        if (_this.isSocketInRoom(socket, args.room)) {
            socket.emit('room.join', {
                success: false,
                room: args.room,
                errors: ['You have already joined this room']
            });
            _this.debug('Join attempt to room', args.room, 'has been failed because already joined');
            return;
        }

        var promiseFactory = require('q').Promise,
            redis = require('promise-redis')(promiseFactory),
            redisClient = redis.createClient({
                db: _this.ENV.REDIS_DATABASE || 0
            });

        redisClient.get(args.room).then(JSON.parse).then(function (data) {
            redisClient.end(true);

            if (_this.isRoomPasswordValid(args.password, data.password) === false) {
                socket.emit('room.join', {success: false, room: args.room, errors: ['Invalid password']});
                socket.broadcast.to(args.room).emit('room.join.attempt', {
                    success: false,
                    room: args.room,
                    errors: ['Somebody tried to join room with invalid password']
                });
                _this.debug('Join attempt to room', args.room, 'has been failed with password', args.password);
                return;
            }

            var User = require('./user');
            var user = new User({socketId: socket.id, excludeNames: _this.getRoomRosterUserNames(args.room)});

            // Send initial connect info to joined user
            socket.emit('room.join', {
                success: true,
                key: data.password,
                name: user.name,
                self: true
            });

            _this.addUserToRoom(socket, user, args.room);

            // Set response listeners for the new user
            _this.setResponseListeners(socket, user);
        }).catch(function (err) {
            socket.emit('room.join', {success: false, room: args.room, errors: ['Invalid password']});
            _this.debug('There is no such room', args.room);
        });
    });
};

/**
 * Method to set response listeners.
 *
 * @param socket
 * @param user
 */
ChatServer.prototype.setResponseListeners = function (socket, user) {
    var _this = this;

    // Triggered when a socket disconnects
    socket.on('disconnect', function () {
        _this.removeSocketFromAllRooms(socket, user);

        socket.removeAllListeners('room.disconnect');
        socket.removeAllListeners('room.data');
    });

    socket.on('room.leave', function (args) {
        if (typeof args == 'undefined') {
            socket.emit('room.leave', {success: false, errors: ['Empty arguments']});
            _this.debug('Cannot leave room without arguments');
            return;
        }

        if (typeof args.room == 'undefined' || args.room.length == 0) {
            socket.emit('room.leave', {success: false, errors: ['Room name is required']});
            _this.debug(user.name, 'no room provided, cannot leave');
            return;
        }

        if (_this.isSocketInRoom(socket, args.room) === false) {
            socket.emit('room.leave', {success: false, errors: ['You are not joined to room ' + args.room]});
            _this.debug(user.name, 'not in room', args.room, 'cannot leave');
            return;
        }

        _this.removeSocketFromRoom(socket, user, args.room);

        socket.removeAllListeners('room.leave');
        socket.removeAllListeners('room.data');
    });

    // Triggered when socket send a chat message
    socket.on('room.data', function (args) {
        if (typeof args == 'undefined') {
            socket.emit('room.data', {success: false, errors: ['Empty arguments']});
            _this.debug('Cannot send data without arguments');
            return;
        }

        if (typeof args.room == 'undefined' || args.room.length == 0) {
            socket.emit('room.data', {success: false, errors: ['Room name is required']});
            _this.debug(user.name, 'sending data without room name');
            return;
        }

        if (typeof args.data == 'undefined' || args.data == '') {
            socket.emit('room.data', {success: false, errors: ['Data is required']});
            _this.debug(user.name, 'sending empty data');
            return;
        }

        if (typeof args.sent_at == 'undefined' || args.sent_at == '') {
            socket.emit('room.data', {success: false, errors: ['Sent at is required']});
            _this.debug(user.name, 'sending empty sent_at');
            return;
        }

        if (_this.isSocketInRoom(socket, args.room) === false) {
            socket.emit('room.data', {success: false, errors: ['You are not authorized in room']});
            socket.to(args.room).emit('room.data.attempt', {
                success: false,
                errors: ['Somebody tried to send message without authorization']
            });
            _this.debug(user.name, 'sending not authorized message');
            return;
        }

        var deliveredAt = new Date().getTime();

        socket.broadcast.to(args.room).emit('room.data', {
            sender: user.name,
            data: args.data,
            sent_at: args.sent_at,
            delivered_at: deliveredAt
        });

        socket.emit('room.data', {
            success: true,
            sent_at: args.sent_at,
            delivered_at: deliveredAt
        });

        _this.debug(user.name, 'sent to room:', args.room, 'a message:', args.data);
    });
};

/**
 * Get users objects joined to room.
 *
 * @param room
 * @returns {*}
 */
ChatServer.prototype.getRoomRoster = function (room) {
    var _this = this;

    if (typeof _this.rooms[room] == 'undefined') {
        return [];
    }

    return _this.rooms[room].map(function (user) {
        return {name: user.name};
    });
};

/**
 * Get user names joined to room.
 *
 * @param room
 * @returns {*}
 */
ChatServer.prototype.getRoomRosterUserNames = function (room) {
    var _this = this;

    if (typeof _this.rooms[room] == 'undefined') {
        return [];
    }

    return _this.rooms[room].map(function (user) {
        return user.name;
    });
};


/**
 * Get all socket ids joined to room.
 *
 * @param room
 * @returns {*}
 */
ChatServer.prototype.getRoomRosterSocketIds = function (room) {
    var _this = this;

    if (typeof _this.rooms[room] == 'undefined') {
        return [];
    }

    return _this.rooms[room].map(function (user) {
        return user.socketId;
    });
};

/**
 * If socket joined to room.
 *
 * @param socket
 * @param room
 * @returns {boolean}
 */
ChatServer.prototype.isSocketInRoom = function (socket, room) {
    return socket.rooms.hasOwnProperty(room);
};

/**
 * Join user to room.
 *
 * @param socket
 * @param user
 * @param room
 */
ChatServer.prototype.addUserToRoom = function (socket, user, room) {
    var _this = this;

    if (typeof _this.rooms[room] == 'undefined') {
        _this.rooms[room] = [];
    }

    socket.join(room);

    user.rooms.push(room);

    _this.rooms[room].push({socketId: socket.id, name: user.name});

    _this.debug(user.name, 'joined to', room);

    socket.broadcast.to(room).emit('room.join', {
        success: true,
        name: user.name,
        self: false
    });

    // Update roster for all users on channel
    socket.to(room).emit('room.roster', _this.getRoomRoster(room));

    // :TODO: Resolve why initiator not receiving it as room message above
    socket.emit('room.roster', _this.getRoomRoster(room));
};

/**
 * Disconnect socket from room.
 *
 * @param socket
 * @param user
 * @param room
 */
ChatServer.prototype.removeSocketFromRoom = function (socket, user, room) {
    var _this = this;

    if (typeof _this.rooms[room] == 'undefined') {
        return;
    }

    socket.leave(room);

    user.rooms.splice(user.rooms.indexOf(room), 1);

    var userIndex = _this.getRoomRosterSocketIds(room).indexOf(socket.id);
    _this.rooms[room].splice(userIndex, 1);

    _this.debug(user.name, 'left room:', room);

    socket.emit('room.leave', {
        success: true,
        self: true,
        room: room
    });

    socket.broadcast.to(room).emit('room.leave', {
        success: true,
        name: user.name,
        self: false
    });

    // Update roster for all users on channel
    socket.to(room).emit('room.roster', _this.getRoomRoster(room));

    if (_this.rooms[room].length == 0) {
        //_this.destroyRoom(room);
    }
};

/**
 * Disconnect socket from all joined rooms.
 *
 * @param socket
 * @param user
 */
ChatServer.prototype.removeSocketFromAllRooms = function (socket, user) {
    var _this = this;
    user.rooms.forEach(function (element) {
        _this.removeSocketFromRoom(socket, user, element);
    })
};

/**
 * Create room.
 *
 * @param socket
 * @param password
 */
ChatServer.prototype.createRoom = function (socket, password) {
    var _this = this,
        bcrypt = require('bcryptjs'),
        saltRounds = 10,
        name = _this.generateRoomName(6);

    bcrypt.genSalt(saltRounds, function (err, salt) {
        bcrypt.hash(password, salt, function (err, hash) {
            var room = {
                password: hash,
                name: name
            };
            room = JSON.stringify(room);

            var promiseFactory = require('q').Promise,
                redis = require('promise-redis')(promiseFactory),
                redisClient = redis.createClient({
                    db: _this.ENV.REDIS_DATABASE || 0
                });

            // :TODO: First of all check if name not exists if exists - generate new name while not found
            redisClient.set(name, room).then(function () {
                socket.emit('room.create', {success: true, room: name});
                _this.debug('Room', name, 'created');

                redisClient.end(true);
            }).catch(function (err) {
                socket.emit('room.create', {success: false, errors: ['Server error. Try again later']});
                _this.debug('Room', name, 'creation failed' + err);

                redisClient.end(true);
            });
        });
    });
};

/**
 * Verify if room token is valid.
 *
 * @param password
 * @param hash
 * @returns {boolean}
 */
ChatServer.prototype.isRoomPasswordValid = function (password, hash) {
    var bcrypt = require('bcryptjs');

    return bcrypt.compareSync(password, hash);
};

/**
 * Room name generation.
 *
 * @param length
 * @returns {string}
 */
ChatServer.prototype.generateRoomName = function (length) {
    length = length || 32;

    var name = '',
        allowedChars = 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789';

    for (var i = 0; i <= length; i++) {
        name += allowedChars.charAt(Math.floor(Math.random() * allowedChars.length));
    }

    return name;
};

/**
 * Echo debug information in console.
 *
 * @param string
 */
ChatServer.prototype.debug = function (string) {
    if (typeof this.ENV.APP_DEBUG == 'undefined' || this.ENV.APP_DEBUG == 'false') {
        return;
    }

    var args = Array.prototype.slice.call(arguments);
    console.log.apply(console, args);
};

module.exports = ChatServer;
